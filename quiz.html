<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SuperfastSAT Diagnostic Test</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://developers.kakao.com/sdk/js/kakao.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        // MathJax CDN 로드 상태 확인
        window.addEventListener('load', function() {
            console.log('🔍 페이지 로드 완료');
            
            // MathJax 스크립트 로드 완료를 기다림
            const mathJaxScript = document.getElementById('MathJax-script');
            if (mathJaxScript) {
                mathJaxScript.addEventListener('load', function() {
                    console.log('✅ MathJax 스크립트 로드 완료');
                    // MathJax가 준비되면 즉시 렌더링
                    setTimeout(() => {
                        if (window.MathJax && window.pendingMathJaxRenders) {
                            console.log('🔍 MathJax 준비됨, 예약된 렌더링 실행');
                            executeAllPendingRenders();
                        }
                    }, 500);
                });
            }
        });
        // MathJax 설정 완전 새로 작성 (TikZ + pgfplots 지원)
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                packages: ['base', 'ams', 'noerrors', 'noundefined', 'tikz', 'pgfplots'],
                macros: {
                    // TikZ 관련 매크로 정의
                    'tikz': '\\text{tikz}',
                    'pgfplots': '\\text{pgfplots}',
                    'draw': '\\text{draw}',
                    'plot': '\\text{plot}',
                    'axis': '\\text{axis}',
                    'addplot': '\\text{addplot}'
                }
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                pageReady: () => {
                    console.log('✅ MathJax 즉시 렌더링 시작 (TikZ 지원)');
                    // 모든 예약된 렌더링 즉시 실행
                    if (window.pendingMathJaxRenders && window.pendingMathJaxRenders.length > 0) {
                        executeAllPendingRenders();
                    }
                }
            }
        };
        
        // 간단한 MathJax 준비 확인 함수
        function checkMathJaxReady() {
            if (window.MathJax && window.MathJax.typesetPromise) {
                console.log('✅ MathJax 준비됨');
                return true;
            }
            return false;
        }
        
        // TikZ 코드를 LaTeX로 변환하는 함수
        function convertTikZToLatex(tikzCode) {
            if (!tikzCode || !tikzCode.includes('tikzpicture')) {
                return tikzCode;
            }
            
            console.log('🔍 TikZ 코드 변환 시작:', tikzCode.substring(0, 100));
            
            // TikZ 환경을 LaTeX로 변환
            let latexCode = tikzCode
                .replace(/\\begin\{tikzpicture\}/g, '\\begin{center}\\begin{tikzpicture}')
                .replace(/\\end\{tikzpicture\}/g, '\\end{tikzpicture}\\end{center}')
                .replace(/\\begin\{axis\}/g, '\\begin{center}\\begin{axis}')
                .replace(/\\end\{axis\}/g, '\\end{axis}\\end{center}');
            
            console.log('✅ TikZ 변환 완료:', latexCode.substring(0, 100));
            return latexCode;
        }
        
        // MathJax가 준비되면 자동으로 렌더링하도록 예약하는 함수
        function scheduleMathJaxRendering(qBlock, row) {
            // 예약된 렌더링을 전역 배열에 저장
            if (!window.pendingMathJaxRenders) {
                window.pendingMathJaxRenders = [];
            }
            
            window.pendingMathJaxRenders.push({ qBlock, row });
            console.log('📝 MathJax 렌더링 예약됨:', row.Number, row.Subject);
        }
        
        // 예약된 모든 렌더링을 실행하는 함수
        function executeAllPendingRenders() {
            if (!window.pendingMathJaxRenders || window.pendingMathJaxRenders.length === 0) {
                console.log('🔍 예약된 렌더링이 없음');
                return;
            }
            
            console.log(`🔍 ${window.pendingMathJaxRenders.length}개의 예약된 렌더링 실행 시작`);
            
            window.pendingMathJaxRenders.forEach(({ qBlock, row }) => {
                console.log('🔍 예약된 렌더링 실행:', row.Number, row.Subject);
                
                // LaTeX 구문 복원 및 렌더링
                const mathElements = qBlock.querySelectorAll('p');
                mathElements.forEach(p => {
                    let html = p.innerHTML;
                    html = html.replace(/&#92;&#91;/g, '\\[');
                    html = html.replace(/&#92;&#93;/g, '\\]');
                    html = html.replace(/&#92;&#40;/g, '\\(');
                    html = html.replace(/&#92;&#41;/g, '\\)');
                    html = html.replace(/&#92;cdot/g, '\\cdot');
                    html = html.replace(/&#92;tfrac/g, '\\tfrac');
                    html = html.replace(/&#92;frac/g, '\\frac');
                    html = html.replace(/&#92;sqrt/g, '\\sqrt');
                    html = html.replace(/&#92;sum/g, '\\sum');
                    html = html.replace(/&#92;int/g, '\\int');
                    
                    if (html !== p.innerHTML) {
                        console.log('🔍 예약된 LaTeX 구문 복원:', html.substring(0, 100));
                        p.innerHTML = html;
                    }
                });
                
                window.MathJax.typesetPromise([qBlock]).then(() => {
                    console.log('✅ 예약된 MathJax 렌더링 완료:', row.Number, row.Subject);
                }).catch(error => {
                    console.error('❌ 예약된 MathJax 렌더링 오류:', error);
                });
            });
            
            // 예약된 렌더링 목록 초기화
            window.pendingMathJaxRenders = [];
        }
    </script>
</head>
<body>
    <div class="container">
        <img src="superfastsat-logo.png" alt="SuperfastSAT Logo" class="logo" style="max-width:320px;display:block;margin:0 auto 16px auto;">
        <h1 style="text-align:center;">SAT Diagnostic Test</h1>
        <form action="/submit" method="POST" id="quizForm">
            <div class="student-info">
                <label for="studentName">Student Name</label>
                <input type="text" id="studentName" name="studentName" required>

                <label for="studentGrade" style="margin-top: 15px;">Grade</label>
                <select id="studentGrade" name="studentGrade" required>
                    <option value="">Select Grade</option>
                    <option value="US05">US05</option>
                    <option value="US06">US06</option>
                    <option value="US07">US07</option>
                    <option value="US08">US08</option>
                    <option value="US09">US09</option>
                    <option value="US10">US10</option>
                    <option value="US11">US11</option>
                    <option value="US12">US12</option>
                    <option value="Y07">Y07</option>
                    <option value="Y08">Y08</option>
                    <option value="Y09">Y09</option>
                    <option value="Y10">Y10</option>
                    <option value="Y11">Y11</option>
                    <option value="Y12">Y12</option>
                    <option value="Y13">Y13</option>
                    <option value="High School Graduate">High School Graduate</option>
                </select>

                <div class="notice-section" style="margin-top: 30px; padding: 20px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid #071BE9;">
                    <h3 style="margin-top: 0; color: #071BE9; font-size: 1.1em;">Important Notice</h3>
                    <p style="margin: 0 0 5px 0; color: #555; font-weight: 700; text-decoration: underline;">You must select both Confidence Rating and Answer to submit properly. Please check all items to quickly receive your diagnostic results. We receive many inquiries from students who cannot click the submit button because they did not select all required items.</p>
                    <ul style="margin: 0; padding-left: 20px; color: #555;">
                        <li style="margin-bottom: 10px;">Please do not use GPT or any AI tools during this diagnostic test. Understanding what you need to study is much more valuable than getting a high score on this test.</li>
                        <li style="margin-bottom: 0;">Havent studied for the SAT yet or worried about not improving your scores? Don't worry! SuperfastSAT is here to fully support your SAT success.</li>
                    </ul>
                </div>

            </div>

            <div id="questions-area"></div>
            <div class="submit-section" id="submitSection" style="display:block; text-align: center; margin-top: 30px;">
                <button type="submit" class="submit-btn" style="background: #071BE9; color: white; padding: 16px 32px; border: none; border-radius: 24px; font-size: 1.1em; font-weight: 600; cursor: pointer; transition: background 0.2s;">
                    Submit
                </button>
            </div>
        </form>
    </div>
    <script>
    let timerStarted = false;
    let timerInterval = null;
    
    // HTML 엔티티를 디코딩하는 함수
    function decodeHtmlEntities(text) {
        if (typeof text !== 'string') return text;
        
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    
    // 텍스트를 안전하게 HTML로 렌더링하는 함수
    function renderTextSafely(text) {
        if (!text) return '';
        
        // HTML 엔티티 디코딩
        let decodedText = decodeHtmlEntities(text);
        
        // 줄바꿈을 <br>로 변환
        decodedText = decodedText.replace(/\n/g, '<br>');
        
        // 추가적인 특수 문자 처리
        // 온도 기호가 제대로 표시되도록 보장
        decodedText = decodedText.replace(/&deg;/g, '°');
        
        // 콤마가 제대로 표시되도록 보장 (숫자 사이의 공백 제거)
        decodedText = decodedText.replace(/(\d)\s+(\d{3})/g, '$1,$2');
        
        // LaTeX 구문을 HTML 엔티티로 변환하여 MathJax가 인식하도록 함
        decodedText = decodedText.replace(/\\\[/g, '&#92;&#91;');
        decodedText = decodedText.replace(/\\\]/g, '&#92;&#93;');
        decodedText = decodedText.replace(/\\\(/g, '&#92;&#40;');
        decodedText = decodedText.replace(/\\\)/g, '&#92;&#41;');
        
        // 추가 LaTeX 명령어들도 HTML 엔티티로 변환
        decodedText = decodedText.replace(/\\cdot/g, '&#92;cdot');
        decodedText = decodedText.replace(/\\tfrac/g, '&#92;tfrac');
        decodedText = decodedText.replace(/\\frac/g, '&#92;frac');
        decodedText = decodedText.replace(/\\sqrt/g, '&#92;sqrt');
        decodedText = decodedText.replace(/\\sum/g, '&#92;sum');
        decodedText = decodedText.replace(/\\int/g, '&#92;int');
        
        // 문장 내 콤마가 제대로 표시되도록 보장
        // "word1  word2" 형태를 "word1, word2"로 변환
        decodedText = decodedText.replace(/([a-zA-Z])\s{2,}([a-zA-Z])/g, '$1, $2');
        
        // 수학 수식에서 특수 문자가 제대로 표시되도록 보장
        // LaTeX 수식 내의 특수 문자 처리
        decodedText = decodedText.replace(/\\([a-zA-Z]+)/g, '\\\\$1');
        
        return decodedText;
    }
    
    // 타이머 위치를 아코디언 기준으로 업데이트하는 함수
    function updateTimerPosition() {
      const activePanel = document.querySelector('.accordion-panel[style*="display: block"]');
      if (activePanel) {
        const panelRect = activePanel.getBoundingClientRect();
        const containerRect = document.querySelector('.container').getBoundingClientRect();
        
        // 뷰포트 기준으로 절대 위치 계산
        const viewportLeft = panelRect.right + 20; // 아코디언 오른쪽에서 20px 떨어진 위치
        
        const timerBox = document.getElementById('timerBox');
        if (timerBox) {
          timerBox.style.left = viewportLeft + 'px';
          timerBox.style.right = 'auto';
        }
      }
    }

    function startTimer(duration) {
      let time = duration;
      const timerBox = document.getElementById('timerBox');
      timerBox.style.display = 'block';
      
      // 타이머를 아코디언 오른쪽에 표시
      updateTimerPosition();
      console.log('⏰ 타이머 시작 - 아코디언 오른쪽');
      
      // 스크롤 시 타이머 위치 유지
      window.addEventListener('scroll', updateTimerPosition);
      
      // 윈도우 리사이즈 시 타이머 위치 업데이트
      window.addEventListener('resize', updateTimerPosition);
      
      // 타이머 드래그 기능 추가
      makeDraggable(timerBox);
      
      function updateTimer() {
        if (time < 0) {
          timerBox.textContent = '시간 종료';
          clearInterval(timerInterval);
          
          // 이벤트 리스너 제거
          window.removeEventListener('scroll', updateTimerPosition);
          window.removeEventListener('resize', updateTimerPosition);
          return;
        }
        const h = String(Math.floor(time / 3600)).padStart(2, '0');
        const m = String(Math.floor((time % 3600) / 60)).padStart(2, '0');
        const s = String(time % 60).padStart(2, '0');
        timerBox.textContent = `Time: ${h}:${m}:${s}`;
        time--;
      }
      updateTimer();
      timerInterval = setInterval(updateTimer, 1000);
    }
    // 동적으로 문제를 생성하는 코드
    document.addEventListener('DOMContentLoaded', function() {
        Papa.parse('questions.csv', {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: function(results) {
                console.log('🔍 CSV 파싱 결과:', results);
                console.log('📊 전체 데이터 개수:', results.data.length);
                
                const data = results.data.filter(row => row.Question || row.Subject === 'Math');
                console.log('✅ Question이 있는 데이터 개수:', data.length);
                
                // Math 문제만 따로 확인
                const mathProblems = data.filter(row => row.Subject === 'Math');
                console.log('🎯 Math 문제 개수:', mathProblems.length);
                mathProblems.forEach((row, idx) => {
                    console.log(`Math ${idx + 1}:`, row.Number, row.Subject, row.QuestionType, 'Question:', row.Question ? '있음' : '없음');
                });
                
                // 필터링된 모든 데이터 확인
                console.log('🔍 필터링된 모든 데이터:');
                data.forEach((row, idx) => {
                    console.log(`${idx + 1}:`, row.Number, row.Subject, row.QuestionType, 'Question:', row.Question ? '있음' : '없음');
                });
                const questionsArea = document.getElementById('questions-area');
                // Number(문제 번호) 기준으로 오름차순 정렬
                data.sort(function(a, b) {
                  const numA = parseInt(a.Number, 10);
                  const numB = parseInt(b.Number, 10);
                  if (isNaN(numA)) return 1;
                  if (isNaN(numB)) return -1;
                  return numA - numB;
                });

                // RW 아코디언 버튼 및 패널 생성
                const rwHeader = document.createElement('button');
                rwHeader.className = 'accordion-header';
                rwHeader.textContent = 'RW';
                rwHeader.type = 'button';
                const rwPanel = document.createElement('div');
                rwPanel.className = 'accordion-panel';
                rwPanel.style.display = 'none';
                rwPanel.style.position = 'relative';
                
                // 타이머를 body에 직접 추가 (문제 영역 옆에 보이도록)
                const timerBox = document.createElement('div');
                timerBox.className = 'timer-box';
                timerBox.id = 'timerBox';
                timerBox.style.display = 'none';
                timerBox.style.position = 'fixed';
                timerBox.style.top = '100px';
                timerBox.style.left = 'auto';
                timerBox.style.right = '20px';
                timerBox.style.zIndex = '1000';
                timerBox.style.background = 'rgba(7, 27, 233, 0.9)';
                timerBox.style.color = 'white';
                timerBox.style.padding = '20px 30px';
                timerBox.style.borderRadius = '12px';
                timerBox.style.fontSize = '24px';
                timerBox.style.fontWeight = 'bold';
                timerBox.style.boxShadow = '0 6px 20px rgba(0, 0, 0, 0.2)';
                timerBox.style.border = '3px solid rgba(255, 255, 255, 0.3)';
                timerBox.style.minWidth = '200px';
                timerBox.style.textAlign = 'center';
                document.body.appendChild(timerBox);
                // RW 아코디언 버튼에 펼침/접힘 기호 추가
                let rwOpen = false;
                const updateRwHeader = () => {
                  rwHeader.textContent = (rwOpen ? '▼ ' : '▶ ') + 'RW';
                };
                updateRwHeader();
                rwHeader.addEventListener('click', function() {
                  rwOpen = !rwOpen;
                  rwPanel.style.display = rwOpen ? 'block' : 'none';
                  updateRwHeader();
                  
                  // RW 아코디언 상태에 따라 required 속성 관리
                  const rwInputs = rwPanel.querySelectorAll('input[required]');
                  rwInputs.forEach(input => {
                    if (rwOpen) {
                      input.required = true;
                    } else {
                      input.required = false;
                    }
                  });
                  
                  if (rwOpen) {
                    startTimerIfFirst('RW');
                    // 타이머 위치를 RW 패널 기준으로 업데이트
                    updateTimerPosition();
                  }
                });

                // Math 아코디언 버튼 및 패널 생성
                const mathHeader = document.createElement('button');
                mathHeader.className = 'accordion-header';
                mathHeader.type = 'button';
                const mathPanel = document.createElement('div');
                mathPanel.className = 'accordion-panel';
                mathPanel.style.display = 'none';
                // Math 아코디언 버튼에 펼침/접힘 기호 추가
                let mathOpen = false;
                const updateMathHeader = () => {
                  mathHeader.textContent = (mathOpen ? '▼ ' : '▶ ') + 'Math';
                };
                updateMathHeader();
                mathHeader.addEventListener('click', function() {
                  mathOpen = !mathOpen;
                  mathPanel.style.display = mathOpen ? 'block' : 'none';
                  updateMathHeader();
                  
                  // Math 아코디언 상태에 따라 required 속성 관리
                  const mathInputs = mathPanel.querySelectorAll('input[required]');
                  mathInputs.forEach(input => {
                    if (mathOpen) {
                      input.required = true;
                    } else {
                      input.required = false;
                    }
                  });
                  
                  if (mathOpen) {
                    startTimerIfFirst('Math');
                    // 타이머 위치를 Math 패널 기준으로 업데이트
                    updateTimerPosition();
                  }
                });

                data.forEach(function(row, idx) {
                    const qNum = row.Number || (idx + 1);
                    const qBlock = document.createElement('div');
                    qBlock.className = 'question-block';
                    
                    // 디버깅: 모든 문제 정보 확인
                    console.log('문제 로드:', row.Number, 'Subject:', row.Subject, 'Type:', row.QuestionType);
                    
                    // Math 문제 특별 확인
                    if (row.Subject === 'Math') {
                        console.log('🎯 Math 문제 발견:', row.Number, row.Subject, row.Question);
                    }
                    
                    // 문제 타입 확인
                    const questionType = row.QuestionType || 'multiple_choice';
                    
                    // Passage
                    if(row.Passage && row.Passage.trim() !== '') {
                        const passageDiv = document.createElement('div');
                        passageDiv.className = 'passage';
                        passageDiv.innerHTML = renderTextSafely(row.Passage);
                        qBlock.appendChild(passageDiv);
                    }
                    // Question N
                    const qNumber = document.createElement('div');
                    qNumber.className = 'question-number';
                    qNumber.textContent = 'Question ' + qNum;
                    qBlock.appendChild(qNumber);
                    // Question Text
                    const qTitle = document.createElement('div');
                    qTitle.className = 'question-title';
                    qTitle.innerHTML = renderTextSafely(row.Question);
                    qBlock.appendChild(qTitle);
                    // Answer label
                    const answerLabel = document.createElement('div');
                    answerLabel.className = 'answer-label';
                    answerLabel.textContent = 'Answer';
                    qBlock.appendChild(answerLabel);
                    
                    // 문제 타입에 따라 다른 UI 생성
                    if (questionType === 'short_answer') {
                        // 주관식 문제 UI
                        const shortAnswerDiv = document.createElement('div');
                        shortAnswerDiv.className = 'short-answer-input';
                        shortAnswerDiv.style.marginBottom = '20px';
                        
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.name = 'q' + row.Subject + qNum;
                        input.required = true;
                        input.placeholder = '답을 입력하세요';
                        input.style.width = '100%';
                        input.style.padding = '12px 16px';
                        input.style.border = '1.5px solid #e5e8f0';
                        input.style.borderRadius = '24px';
                        input.style.fontSize = '1.08em';
                        input.style.background = '#fafbfc';
                        input.style.boxSizing = 'border-box';
                        
                        shortAnswerDiv.appendChild(input);
                        qBlock.appendChild(shortAnswerDiv);
                    } else {
                        // 객관식 문제 UI
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options';
                    ['A','B','C','D'].forEach(function(opt) {
                        const rowDiv = document.createElement('div');
                        rowDiv.className = 'option-row';
                        rowDiv.style.display = 'flex';
                        rowDiv.style.alignItems = 'center';
                        rowDiv.style.marginBottom = '10px';
                        // 알파벳 라벨 (테두리 바깥)
                        const alphaLabel = document.createElement('span');
                        alphaLabel.textContent = opt;
                        alphaLabel.className = 'option-alpha-label';
                        rowDiv.appendChild(alphaLabel);
                        // 보기 라벨 (테두리 안)
                        const label = document.createElement('label');
                        label.style.display = 'flex';
                        label.style.alignItems = 'center';
                        label.style.width = '100%';
                        label.style.padding = '2px 16px'; // 위아래 2px, 좌우 16px
                        label.style.border = '1.5px solid #e5e8f0';
                        label.style.borderRadius = '24px';
                        label.style.background = '#fafbfc';
                        label.style.fontWeight = '500';
                        label.style.fontSize = '1.08em';
                        label.style.transition = 'border 0.2s, background 0.2s';
                        const input = document.createElement('input');
                        input.type = 'radio';
                        input.name = 'q' + row.Subject + qNum;
                        input.value = opt;
                        input.style.marginRight = '16px';
                        input.style.accentColor = '#071BE9';
                        if(opt==='A') input.required = true;
                        label.appendChild(input);
                        const span = document.createElement('span');
                        span.innerHTML = renderTextSafely(row['Option'+opt]);
                        label.appendChild(span);
                        rowDiv.appendChild(label);
                        optionsDiv.appendChild(rowDiv);
                    });
                    qBlock.appendChild(optionsDiv);
                    }
                    // Confidence Rating (Answer 아래로 이동)
                    const confLabel = document.createElement('div');
                    confLabel.className = 'confidence-label';
                    confLabel.textContent = 'Confidence Rating';
                    qBlock.appendChild(confLabel);
                    const confBtns = document.createElement('div');
                    confBtns.className = 'confidence-buttons';
                    confBtns.style.display = 'flex';
                    confBtns.style.gap = '12px';
                    (row.ConfidenceOptions || '0,25,50,75,100').split(',').forEach(function(val, i) {
                        const label = document.createElement('label');
                        label.className = 'confidence-btn';
                        label.style.cursor = 'pointer';
                        label.style.display = 'flex';
                        label.style.alignItems = 'center';
                        label.style.justifyContent = 'center';
                        label.style.marginRight = '8px';
                        label.style.height = '40px';
                        label.style.minWidth = '64px';
                        label.style.border = '1.5px solid #e5e8f0';
                        label.style.borderRadius = '6px';
                        label.style.padding = '4px 12px';
                        label.style.background = '#fff';
                        label.style.transition = 'background 0.2s, color 0.2s, border 0.2s';
                        const input = document.createElement('input');
                        input.type = 'radio';
                        input.name = 'c' + row.Subject + qNum;
                        input.value = val;
                        input.style.marginRight = '6px';
                        input.style.accentColor = '#071BE9';
                        if(i===0) input.required = true;
                        label.appendChild(input);
                        const span = document.createElement('span');
                        span.textContent = val + '%';
                        span.style.display = 'inline-block';
                        span.style.width = '100%';
                        span.style.textAlign = 'center';
                        label.appendChild(span);
                        confBtns.appendChild(label);
                    });
                    qBlock.appendChild(confBtns);

                    // Subject 컬럼 기준으로 분류
                    console.log('🔍 문제 분류:', row.Number, 'Subject:', row.Subject, 'Type:', typeof row.Subject, 'Length:', row.Subject ? row.Subject.length : 0);
                    
                    if (row.Subject && row.Subject.trim() === 'Math') {
                      console.log('✅ Math 패널에 추가:', row.Number);
                      mathPanel.appendChild(qBlock);
                    } else {
                      console.log('📚 RW 패널에 추가:', row.Number);
                      rwPanel.appendChild(qBlock);
                    }

                    // MathJax 동적 렌더링 트리거 (특수 문자 처리 후)
                    if (checkMathJaxReady()) {
                      // MathJax가 준비된 경우 즉시 렌더링
                      setTimeout(() => {
                        try {
                          console.log('🔍 MathJax 렌더링 시작:', row.Number, row.Subject);
                          
                                              // LaTeX 구문을 강제로 복원하여 MathJax가 인식하도록 함
                    const mathElements = qBlock.querySelectorAll('p');
                    mathElements.forEach(p => {
                        let html = p.innerHTML;
                        // HTML 엔티티를 다시 LaTeX 구문으로 복원
                        html = html.replace(/&#92;&#91;/g, '\\[');
                        html = html.replace(/&#92;&#93;/g, '\\]');
                        html = html.replace(/&#92;&#40;/g, '\\(');
                        html = html.replace(/&#92;&#41;/g, '\\)');
                        html = html.replace(/&#92;cdot/g, '\\cdot');
                        html = html.replace(/&#92;tfrac/g, '\\tfrac');
                        html = html.replace(/&#92;frac/g, '\\frac');
                        html = html.replace(/&#92;sqrt/g, '\\sqrt');
                        html = html.replace(/&#92;sum/g, '\\sum');
                        html = html.replace(/&#92;int/g, '\\int');
                        
                        // TikZ 코드 변환 적용
                        html = convertTikZToLatex(html);
                        
                        if (html !== p.innerHTML) {
                            console.log('🔍 LaTeX 구문 복원 + TikZ 변환:', html.substring(0, 100));
                            p.innerHTML = html;
                        }
                    });
                          
                          window.MathJax.typesetPromise([qBlock]).then(() => {
                            console.log('✅ MathJax 렌더링 완료:', row.Number, row.Subject);
                          }).catch(error => {
                            console.error('❌ MathJax 렌더링 오류:', error);
                          });
                        } catch (error) {
                          console.error('❌ MathJax typesetPromise 오류:', error);
                        }
                      }, 100);
                    } else {
                      // MathJax가 준비되지 않은 경우 예약
                      scheduleMathJaxRendering(qBlock, row);
                    }
                });
                // 통합 타이머 시작 함수
                function startTimerIfFirst(accordionType) {
                  if (!timerStarted) {
                    timerStarted = true;
                    console.log(`⏰ ${accordionType} 아코디언에서 타이머 시작 (30분)`);
                    startTimer(1800); // 30분 (1800초)
                  } else {
                    console.log(`⏰ 타이머가 이미 실행 중입니다 (${accordionType} 아코디언)`);
                  }
                }
                
                // RW, Math 아코디언 버튼/패널을 questionsArea에 추가
                questionsArea.insertBefore(rwHeader, questionsArea.firstChild);
                questionsArea.insertBefore(rwPanel, rwHeader.nextSibling);
                questionsArea.insertBefore(mathHeader, rwPanel.nextSibling);
                questionsArea.insertBefore(mathPanel, mathHeader.nextSibling);
                
                // Math 패널 상태 확인
                console.log('🔍 Math 패널 상태 확인:');
                console.log('Math 패널 자식 요소 개수:', mathPanel.children.length);
                console.log('Math 패널 내용:', mathPanel.innerHTML);
                
                // RW 패널 상태 확인
                console.log('🔍 RW 패널 상태 확인:');
                console.log('RW 패널 자식 요소 개수:', rwPanel.children.length);
                
                // 모든 문제 로드 후 MathJax 재렌더링
                setTimeout(() => {
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        console.log('🔍 전체 페이지 MathJax 재렌더링 시작');
                        
                        // 전체 페이지에서 LaTeX 구문을 강제로 복원
                        const allMathElements = document.querySelectorAll('p');
                        allMathElements.forEach(p => {
                            let html = p.innerHTML;
                            // HTML 엔티티를 다시 LaTeX 구문으로 복원
                            html = html.replace(/&#92;&#91;/g, '\\[');
                            html = html.replace(/&#92;&#93;/g, '\\]');
                            html = html.replace(/&#92;&#40;/g, '\\(');
                            html = html.replace(/&#92;&#41;/g, '\\)');
                            html = html.replace(/&#92;cdot/g, '\\cdot');
                            html = html.replace(/&#92;tfrac/g, '\\tfrac');
                            html = html.replace(/&#92;frac/g, '\\frac');
                            html = html.replace(/&#92;sqrt/g, '\\sqrt');
                            html = html.replace(/&#92;sum/g, '\\sum');
                            html = html.replace(/&#92;int/g, '\\int');
                            
                            if (html !== p.innerHTML) {
                                console.log('🔍 전체 페이지 LaTeX 구문 복원:', html.substring(0, 100));
                                p.innerHTML = html;
                            }
                        });
                        
                        window.MathJax.typesetPromise().then(() => {
                            console.log('✅ 전체 페이지 MathJax 렌더링 완료');
                        }).catch(error => {
                            console.error('❌ 전체 페이지 MathJax 렌더링 오류:', error);
                        });
                    }
                }, 800);
                
                // 초기 상태에서 숨겨진 패널의 required 속성 제거
                const hiddenInputs = document.querySelectorAll('.accordion-panel[style*="display: none"] input[required]');
                hiddenInputs.forEach(input => {
                  input.required = false;
                });
                
                // 실시간 검증 설정
                setupRealTimeValidation();
            }
        });


    });

    // 폼 제출 시 검증 및 제출 처리
    document.getElementById('quizForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const validationResult = validateAllFields();
        
        if (!validationResult.isValid) {
            // 누락된 항목이 있으면 메시지 창 표시
            showValidationMessage(validationResult.missingItems, validationResult.subjectResults);
            return;
        }
        
        // 모든 필수 요소가 완료되면 메시지 창 없이 바로 폼 제출
        this.submit();
    });
    
    // 모든 필수 필드 검증 함수
    function validateAllFields() {
        const form = document.getElementById('quizForm');
        const missingItems = [];
        
        // 1. 이름 체크
        const studentName = form.querySelector('#studentName');
        if (!studentName.value.trim()) {
            missingItems.push('Student Name');
        }
        
        // 2. Grade 체크
        const studentGrade = form.querySelector('#studentGrade');
        if (!studentGrade.value) {
            missingItems.push('Grade');
        }
        
        // 3. 과목별로 답안과 확신도 체크
        const allInputs = Array.from(form.querySelectorAll('input[type="radio"], input[type="text"]'));
        const questionNames = new Set();
        const confidenceNames = new Set();
        
        allInputs.forEach(input => {
            if (input.name.startsWith('q')) questionNames.add(input.name);
            if (input.name.startsWith('c')) confidenceNames.add(input.name);
        });
        
        // 과목별로 분류
        const rwMissingAnswers = [];
        const rwMissingConfidence = [];
        const mathMissingAnswers = [];
        const mathMissingConfidence = [];
        
        // 답안 체크 (과목별로 분류)
        questionNames.forEach(name => {
            const group = form.querySelectorAll(`input[name='${name}']`);
            const isChecked = Array.from(group).some(input => input.checked || (input.type === 'text' && input.value.trim() !== ''));
            if (!isChecked) {
                // 과목 판별 (RW 또는 Math)
                if (name.includes('RW')) {
                    const questionNum = name.replace('qRW', '');
                    rwMissingAnswers.push(questionNum);
                } else if (name.includes('Math')) {
                    const questionNum = name.replace('qMath', '');
                    mathMissingAnswers.push(questionNum);
                }
            }
        });
        
        // 확신도 체크 (과목별로 분류)
        confidenceNames.forEach(name => {
            const group = form.querySelectorAll(`input[name='${name}']`);
            const isChecked = Array.from(group).some(input => input.checked);
            if (!isChecked) {
                // 과목 판별 (RW 또는 Math)
                if (name.includes('RW')) {
                    const questionNum = name.replace('cRW', '');
                    rwMissingConfidence.push(questionNum);
                } else if (name.includes('Math')) {
                    const questionNum = name.replace('cMath', '');
                    mathMissingConfidence.push(questionNum);
                }
            }
        });
        
        // 과목별 결과 구성
        const subjectResults = [];
        
        if (rwMissingAnswers.length > 0 || rwMissingConfidence.length > 0) {
            const rwItems = [];
            if (rwMissingAnswers.length > 0) {
                rwItems.push(`Answer: ${rwMissingAnswers.join(', ')}`);
            }
            if (rwMissingConfidence.length > 0) {
                rwItems.push(`Confidence Rating: ${rwMissingConfidence.join(', ')}`);
            }
            subjectResults.push(`RW:\n  • ${rwItems.join('\n  • ')}`);
        }
        
        if (mathMissingAnswers.length > 0 || mathMissingConfidence.length > 0) {
            const mathItems = [];
            if (mathMissingAnswers.length > 0) {
                mathItems.push(`Answer: ${mathMissingAnswers.join(', ')}`);
            }
            if (mathMissingConfidence.length > 0) {
                mathItems.push(`Confidence Rating: ${mathMissingConfidence.join(', ')}`);
            }
            subjectResults.push(`Math:\n  • ${mathItems.join('\n  • ')}`);
        }
        
        return {
            isValid: missingItems.length === 0 && subjectResults.length === 0,
            missingItems: missingItems,
            subjectResults: subjectResults
        };
    }
    
    // Submit 버튼 클릭 시 검증 메시지 표시 함수
    function showValidationMessage(missingItems, subjectResults) {
        // 기존 메시지 찾기 (아코디언 패널 내부에서 먼저 찾기)
        let existingMessage = document.querySelector('.accordion-panel .validation-message') || document.querySelector('.validation-message');
        
        if (missingItems.length === 0 && subjectResults.length === 0) {
            // 모든 항목이 완료되면 메시지 숨김 (애니메이션과 함께)
            if (existingMessage) {
                existingMessage.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => existingMessage.remove(), 300);
            }
            return;
        }
        
        let message = 'Please complete the following required fields:\n\n';
        
        // 기본 정보 (이름, Grade)
        if (missingItems.length > 0) {
            message += 'Basic Information:\n';
            missingItems.forEach(item => {
                message += `  • ${item}\n`;
            });
            message += '\n';
        }
        
        // 과목별 정보
        if (subjectResults.length > 0) {
            subjectResults.forEach(subject => {
                message += `${subject}\n\n`;
            });
        }
        
        if (existingMessage) {
            // 기존 메시지가 있으면 내용만 업데이트 (애니메이션 없음)
            existingMessage.textContent = message;
            // 위치도 재조정
            updateMessagePosition(existingMessage);
        } else {
            // 새 메시지 생성 (첫 번째 표시 시에만 애니메이션)
            const messageDiv = document.createElement('div');
            messageDiv.className = 'validation-message';
            messageDiv.style.cssText = `
                position: fixed;
                top: 120px;
                background: #e74c3c;
                color: white;
                padding: 14px 40px;
                border-radius: 12px;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 4px 16px rgba(231, 76, 60, 0.3);
                width: 450px;
                white-space: pre-line;
                line-height: 1.5;
                font-size: 14px;
                animation: slideInRight 0.3s ease-out;
                letter-spacing: 1px;
                cursor: grab;
            `;
            
            messageDiv.textContent = message;
            
            // 메시지 창을 body에 추가하고 아코디언 패널 위치를 기준으로 고정
            document.body.appendChild(messageDiv);
            
            // 위치 설정
            updateMessagePosition(messageDiv);
            
            // 메시지 창 드래그 기능 추가
            makeDraggable(messageDiv);
        }
    }
    
    // 메시지 창 위치 업데이트 함수
    function updateMessagePosition(messageDiv) {
        const activePanel = document.querySelector('.accordion-panel[style*="display: block"]');
        if (activePanel) {
            const panelRect = activePanel.getBoundingClientRect();
            const containerRect = document.querySelector('.container').getBoundingClientRect();
            const maxLeft = window.innerWidth - messageDiv.offsetWidth - 20; // 오른쪽 여백 20px
            
            // 뷰포트 기준으로 위치 계산
            let leftPosition = panelRect.right + 10;
            
            // 화면 밖으로 나가지 않도록 조정
            if (leftPosition > maxLeft) {
                leftPosition = maxLeft;
            }
            
            // 최소 왼쪽 여백 보장
            if (leftPosition < 20) {
                leftPosition = 20;
            }
            
            messageDiv.style.left = leftPosition + 'px';
        }
    }
    
    // 실시간 검증을 위한 이벤트 리스너들
    function setupRealTimeValidation() {
        const form = document.getElementById('quizForm');
        
        // 모든 입력 요소에 이벤트 리스너 추가
        const allInputs = form.querySelectorAll('input[type="text"], input[type="radio"], select');
        
        allInputs.forEach(input => {
            input.addEventListener('change', function() {
                // 메시지 창이 이미 노출되어 있을 때만 실시간 업데이트
                const existingMessage = document.querySelector('.validation-message');
                if (existingMessage) {
                    // 약간의 지연을 두어 값이 업데이트된 후 검증 실행
                    setTimeout(() => {
                        const validationResult = validateAllFields();
                        if (validationResult.missingItems.length > 0 || validationResult.subjectResults.length > 0) {
                            showValidationMessage(validationResult.missingItems, validationResult.subjectResults);
                        } else {
                            // 모든 항목이 완료되면 메시지 숨김
                            const existingMessage = document.querySelector('.accordion-panel .validation-message') || document.querySelector('.validation-message');
                            if (existingMessage) {
                                existingMessage.remove();
                            }
                        }
                    }, 100);
                }
            });
        });
    }
    
    // 윈도우 리사이즈 시 타이머와 메시지 창 위치 재조정
    window.addEventListener('resize', function() {
        const timerBox = document.getElementById('timerBox');
        const messageDiv = document.querySelector('.validation-message');
        
        if (timerBox && timerBox.style.display !== 'none') {
            const activePanel = document.querySelector('.accordion-panel[style*="display: block"]');
            if (activePanel) {
                const panelRect = activePanel.getBoundingClientRect();
                const maxLeft = window.innerWidth - timerBox.offsetWidth - 20;
                
                let leftPosition = panelRect.right + 10;
                if (leftPosition > maxLeft) {
                    leftPosition = maxLeft;
                }
                if (leftPosition < 20) {
                    leftPosition = 20;
                }
                
                timerBox.style.left = leftPosition + 'px';
            }
        }
        
        if (messageDiv) {
            updateMessagePosition(messageDiv);
        }
    });
    
    // 스크롤 시에도 위치 재조정
    window.addEventListener('scroll', function() {
        const timerBox = document.getElementById('timerBox');
        const messageDiv = document.querySelector('.validation-message');
        
        if (timerBox && timerBox.style.display !== 'none') {
            const activePanel = document.querySelector('.accordion-panel[style*="display: block"]');
            if (activePanel) {
                const panelRect = activePanel.getBoundingClientRect();
                const maxLeft = window.innerWidth - timerBox.offsetWidth - 20;
                
                let leftPosition = panelRect.right + 10;
                if (leftPosition > maxLeft) {
                    leftPosition = maxLeft;
                }
                if (leftPosition < 20) {
                    leftPosition = 20;
                }
                
                timerBox.style.left = leftPosition + 'px';
            }
        }
        
        if (messageDiv) {
            updateMessagePosition(messageDiv);
        }
    });
    
    // 줌 레벨 변경 감지 및 위치 재조정
    let lastZoom = window.devicePixelRatio;
    const checkZoomAndUpdate = () => {
        if (Math.abs(window.devicePixelRatio - lastZoom) > 0.1) {
            lastZoom = window.devicePixelRatio;
            setTimeout(() => {
                const timerBox = document.getElementById('timerBox');
                const messageDiv = document.querySelector('.validation-message');
                
                if (timerBox && timerBox.style.display !== 'none') {
                    const activePanel = document.querySelector('.accordion-panel[style*="display: block"]');
                    if (activePanel) {
                        const panelRect = activePanel.getBoundingClientRect();
                        const maxLeft = window.innerWidth - timerBox.offsetWidth - 20;
                        
                        let leftPosition = panelRect.right + 10;
                        if (leftPosition > maxLeft) {
                            leftPosition = maxLeft;
                        }
                        if (leftPosition < 20) {
                            leftPosition = 20;
                        }
                        
                        timerBox.style.left = leftPosition + 'px';
                    }
                }
                
                if (messageDiv) {
                    updateMessagePosition(messageDiv);
                }
            }, 100);
        }
    };
    
    // 줌 변경 감지를 위한 주기적 체크
    setInterval(checkZoomAndUpdate, 500);
    
    // 드래그 앤 드롭 기능 함수
    function makeDraggable(element) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;
        
        // 드래그 시작
        function dragStart(e) {
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
            
            if (e.target === element) {
                isDragging = true;
                element.style.cursor = 'grabbing';
                element.style.userSelect = 'none';
            }
        }
        
        // 드래그 중
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                
                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                
                xOffset = currentX;
                yOffset = currentY;
                
                // 경계 제한 제거 - 자유롭게 드래그 가능
                
                setTranslate(currentX, currentY, element);
            }
        }
        
        // 드래그 종료
        function dragEnd() {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
            element.style.cursor = 'grab';
            element.style.userSelect = 'auto';
        }
        
        // 위치 설정
        function setTranslate(xPos, yPos, el) {
            el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
        }
        
        // 마우스 이벤트
        element.addEventListener("mousedown", dragStart);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", dragEnd);
        
        // 터치 이벤트 (모바일 지원)
        element.addEventListener("touchstart", dragStart, { passive: false });
        document.addEventListener("touchmove", drag, { passive: false });
        document.addEventListener("touchend", dragEnd);
        
        // 드래그 가능함을 나타내는 스타일
        element.style.cursor = 'grab';
        element.style.userSelect = 'none';
    }
    

    

    
    // 상세한 알림 메시지 함수
    function showDetailedNotification(message) {
        // 기존 알림 제거
        const existingNotification = document.querySelector('.detailed-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // 새 알림 생성
        const notification = document.createElement('div');
        notification.className = 'detailed-notification';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #e74c3c;
            color: white;
            padding: 20px 30px;
            border-radius: 12px;
            font-weight: 600;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            animation: slideDown 0.3s ease-out;
            max-width: 500px;
            white-space: pre-line;
            line-height: 1.5;
            font-size: 14px;
        `;
        
        // 메시지 내용
        const messageDiv = document.createElement('div');
        messageDiv.textContent = message;
        messageDiv.style.marginBottom = '15px';
        notification.appendChild(messageDiv);
        
        // 버튼 컨테이너
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.style.justifyContent = 'flex-end';
        
        // 접어두기 버튼
        const minimizeBtn = document.createElement('button');
        minimizeBtn.textContent = '접어두기';
        minimizeBtn.style.cssText = `
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        `;
        minimizeBtn.onmouseover = () => minimizeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
        minimizeBtn.onmouseout = () => minimizeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
        minimizeBtn.onclick = () => {
            notification.style.transform = 'translateX(-50%) translateY(-10px)';
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
        };
        
        // X 버튼
        const closeBtn = document.createElement('button');
        closeBtn.textContent = '✕';
        closeBtn.style.cssText = `
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        `;
        closeBtn.onmouseover = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
        closeBtn.onmouseout = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
        closeBtn.onclick = () => {
            notification.style.animation = 'slideUp 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        };
        
        buttonContainer.appendChild(minimizeBtn);
        buttonContainer.appendChild(closeBtn);
        notification.appendChild(buttonContainer);
        
        document.body.appendChild(notification);
    }
    </script>
    <style>
    .accordion-header {
      width: 100%;
      text-align: left;
      padding: 14px;
      font-size: 1.1em;
      background: #fff;
      border: 2px solid #071BE9;
      border-radius: 24px;
      margin-bottom: 12px;
      cursor: pointer;
      outline: none;
      transition: background 0.2s, border 0.2s;
    }
    .accordion-header:hover {
      background: #f3f4f6;
    }
    .accordion-panel {
      padding: 0 14px 14px 14px;
      border-bottom: 1px solid #e5e8f0;
      background: #fff;
    }
    .option-row {
      display: flex;
      align-items: center;
    }
    .option-alpha-label {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      min-width: 32px;
      height: 32px;
      font-weight: 700;
      font-size: 1.08em;
      color: #071BE9;
      background: #fff;
      border: 2px solid #d1d5db;
      border-radius: 50%;
      margin-right: 12px;
      user-select: none;
      box-sizing: border-box;
      transition: border 0.2s, background 0.2s;
    }
    .timer-box {
      position: fixed;
      top: 20px;
      z-index: 1000;
      background: #071BE9;
      color: #fff;
      font-size: 1.35em;
      font-weight: 700;
      padding: 14px 40px;
      border-radius: 32px;
      box-shadow: 0 4px 16px rgba(7,27,233,0.08);
      letter-spacing: 1px;
      transition: background 0.2s;
      opacity: 0.97;
      white-space: nowrap;
      cursor: grab;
    }
    
    .timer-box:active {
      cursor: grabbing;
    }
    
    /* 반응형 디자인 */
    @media (max-width: 768px) {
      .timer-box {
        font-size: 1.1em;
        padding: 12px 24px;
        top: 15px;
      }
    }
    
    @media (max-width: 480px) {
      .timer-box {
        font-size: 1em;
        padding: 10px 20px;
        top: 10px;
      }
    }
    
    /* 메시지 창 반응형 디자인 */
    @media (max-width: 768px) {
      .validation-message {
        width: 350px !important;
        font-size: 12px !important;
        padding: 12px 20px !important;
      }
    }
    
    @media (max-width: 480px) {
      .validation-message {
        width: 300px !important;
        font-size: 11px !important;
        padding: 10px 16px !important;
      }
    }
    
    /* 드래그 가능한 요소 스타일 */
    .validation-message:active {
      cursor: grabbing !important;
    }
    .submit-btn:hover {
      background: #0515c7 !important;
    }
    
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    @keyframes slideUp {
      from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      to {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
    }
    
    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes slideOutRight {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }
    </style>
</body>
</html>